"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = exports.Convert = void 0;
const requester_1 = require("./parts/requester");
const config_1 = require("./parts/config");
var chainer_1 = require("./parts/chainer");
Object.defineProperty(exports, "Convert", { enumerable: true, get: function () { return chainer_1.Chainer; } });
const await_to_js_1 = __importDefault(require("await-to-js"));
const axios_1 = __importDefault(require("axios"));
/**
 * Regular converter class definition.
 *
 * @export
 * @class Converter
 */
class Converter {
    /**
     * Creates an instance of Converter.
     * @param {(...ProviderReference[] | undefined[] | string[])} config
     * @memberof Converter
     */
    constructor(...config) {
        /**
         * Method to set the proxy configuration.
         * @param proxyConfiguration  The proxy configuration.
         */
        this.setProxyConfiguration = (proxyConfiguration) => {
            this.config.setClient(axios_1.default.create({ proxy: proxyConfiguration }));
        };
        /**
         * Conversion function (non chainable).
         *
         * @example
         * const converter = new Converter()
         * const converted = await converter.convert(15,"USD","EUR")
         * console.log(converted);
         *
         * @param {number} amount - amount to be converted
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns {Promise<number>} - converted amount
         */
        this.convert = (amount, from, to, rates = undefined) => __awaiter(this, void 0, void 0, function* () {
            // Returining conversion from provided rates
            if (typeof rates !== "undefined") {
                return this.convertRate(amount, to, rates);
            }
            //Fetching conversion rates from the active provider
            const [err, data] = yield (0, await_to_js_1.default)(this.getRates(from, to, false));
            if (err) {
                throw err;
            }
            if (!data || Object.keys(data).length == 0) {
                throw new Error("No data returned for rate fetch.");
            }
            // Normalizing resulting rates data
            return this.convertRate(amount, to, data);
        });
        /**
         * Performs safe multiplication to get the result amount.
         * @param {number} amount - amount to be converted
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns
         */
        this.convertRate = (amount, to, rates = undefined) => {
            if (!rates[to]) {
                throw new Error(`No '${to}' present in rates: ${rates}`);
            }
            return amount * rates[to];
        };
        /**
         * Rate fetch function
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {boolean} multiple - determines conversion mode
         * @returns
         */
        this.getRates = (from, to, multiple = false) => __awaiter(this, void 0, void 0, function* () {
            // Getting the current active provider
            const provider = this.config.activeProvider();
            // Getting the client
            const client = this.config.getClient();
            // Fetching conversion rates from the active provider.
            const [err, data] = yield (0, await_to_js_1.default)((0, requester_1.fetchRates)(client, provider, {
                FROM: from,
                TO: to,
                multiple: multiple
            }));
            // error handling:
            // if the error is not in the registered list of errors (is undefined), then throw.
            // if the error is in the list, but there are no backup providers, then throw.
            // if the error is in the list and there is a backup, log the error and continue.
            if (!err) {
                return provider.handler(data);
            }
            // unrecognized error
            if (!err.handled) {
                throw err.error;
            }
            // logging existing error
            console.error(err.error);
            if (this.config.providers.length <= 1) {
                throw err.error;
            }
            // removing current provider from active list
            this.config.remove(provider);
            // Retrying...
            return this.getRates(from, to, multiple);
        });
        this.config = new config_1.Config(...config);
        // Forwarding config adder function (with the alternative handle)
        this.add = this.config.add;
        this.addProvider = this.config.add;
        // Forwarding config multiple adder function (with the alternative handle)
        this.addMultiple = this.config.addMultiple;
        this.addMultipleProviders = this.config.addMultiple;
        this.remove = this.config.remove;
    }
    /**
     * Getters for active providers
     *
     * @readonly
     * @type {Provider[]}
     * @memberof Converter
     */
    get providers() {
        return this.config.providers;
    }
    get active() {
        return this.config.providers;
    }
}
exports.Converter = Converter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpREFBK0M7QUFFL0MsMkNBQTREO0FBQzVELDJDQUFxRDtBQUE1QyxrR0FBQSxPQUFPLE9BQVc7QUFDM0IsOERBQThCO0FBQzlCLGtEQUEwQjtBQVkxQjs7Ozs7R0FLRztBQUNILE1BQWEsU0FBUztJQVNwQjs7OztPQUlHO0lBQ0gsWUFBWSxHQUFHLE1BQW9EO1FBcUNuRTs7O1dBR0c7UUFDSCwwQkFBcUIsR0FBRyxDQUFDLGtCQUFzQyxFQUFFLEVBQUU7WUFDakUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsZUFBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDLENBQUM7UUFFRjs7Ozs7Ozs7Ozs7OztXQWFHO1FBQ0gsWUFBTyxHQUFHLENBQ1IsTUFBYyxFQUNkLElBQVksRUFDWixFQUFVLEVBQ1YsUUFBYSxTQUFTLEVBQ0wsRUFBRTtZQUNuQiw0Q0FBNEM7WUFDNUMsSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLEVBQUU7Z0JBQ2hDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQzVDO1lBRUQsb0RBQW9EO1lBQ3BELE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxJQUFBLHFCQUFHLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFOUQsSUFBSSxHQUFHLEVBQUU7Z0JBQ1AsTUFBTSxHQUFHLENBQUM7YUFDWDtZQUVELElBQUksQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFN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